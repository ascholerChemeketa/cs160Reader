<section xml:id="algorithms_merge-sort-compared">
        <title>Merge Sort Compared</title>
        <p>We have established that the Merge Sort algorithm requires <m>O(n&#183;log_2(n))</m> work to sort a list of size <term>n</term>. How does that compare to Insertion and Selection sort that are <m>O(n^2)</m>?</p>
        <p>Below is a graph of the growth of <m>n^2</m> and <m>n&#183;log_2(n)</m>:</p>
        <figure align="" xml:id=""><image source="Algorithms/Images/Sorts.svg" width="50%"/></figure>
        <p>Obviously, <m>n^2</m> grows much faster than <m>n&#183;log_2(n)</m>. Looking at the table below, we can see that sorting 500 items with Insertion Sort (<m>O(n^2)</m>) would take somewhere around 250,000 units of work. Doing the same task with Merge Sort would only take around 4,483 units of work!</p>
        <table><tabular>
            
                
                
                
                
                
                
                
                
                    <row header="yes">
                        <cell>
                            <term>Problem size</term>
                        </cell>
                        <cell>
                            10
                        </cell>
                        <cell>
                            100
                        </cell>
                        <cell>
                            500
                        </cell>
                        <cell>
                            1,000
                        </cell>
                        <cell>
                            10,000
                        </cell>
                        <cell>
                            100,000
                        </cell>
                    </row>
                
                
                    <row>
                        <cell>
                            <m>n \cdot log_2(n)</m>
                        </cell>
                        <cell>
                            33
                        </cell>
                        <cell>
                            664
                        </cell>
                        <cell>
                            4,483
                        </cell>
                        <cell>
                            9,966
                        </cell>
                        <cell>
                            132,877
                        </cell>
                        <cell>
                            1,660,964
                        </cell>
                    </row>
                    <row>
                        <cell>
                            <m>n^2</m>
                        </cell>
                        <cell>
                            100
                        </cell>
                        <cell>
                            10,000
                        </cell>
                        <cell>
                            250,000
                        </cell>
                        <cell>
                            1,000,000
                        </cell>
                        <cell>
                            100,000,000
                        </cell>
                        <cell>
                            10,000,000,000
                        </cell>
                    </row>
                
            
        </tabular></table>
        <p>Using the Big-O classification of each algorithm like this gives us a rough estimate of the work. We are ignoring constant factors that may change the exact numbers (especially for low values of n). Merge Sort has more basic overhead than Insertion Sort (for example, we have to copy items to and from a second list) - if you are solving small problems it may take more time to run than Insertion Sort due to this. But we know that as <term>n</term> grows larger the basic pattern is going to hold - <m>O(n^2)</m> is going to grow faster than <m>O(n&#183;log_2(n))</m>, so Merge Sort will certainly be faster out for large values of <term>n</term>.</p>
        <p>Below, you can use the Sort Timer to simulate running sorts of different sizes using the two algorithms. You can use the slider to change the size of the list being sorted. Try comparing the two algorithms at different sort sizes. Does Merge Sort always win? At what point does Insertion Sort start taking more than a half-second to run? At what point does Merges Sort start taking more than a half-second?</p>
        <image source="Algorithms/Images/working.gif" width="50%"/>
        <raw format="html" xml:space="preserve">&lt;style&gt;
  #sorterBox {
    width: 600px;
    border: 1px solid #ccc;
    border-radius: 4px;
  }
  #sorterBox legend {
    width: auto;
    margin: 0px 0px 0px 10px;
    border: none;
  }
  .sortRow {
    padding: 5px 10px;
  }
  #probSizeEntry {
    margin-right: 20px;
  }
  #probSizeText {
    text-align: center;
    width: 150px;
    margin-bottom: 10px;
  }
  #sizeBox {
    float: right;
    padding-bottom: 15px;
    width: 200px;
  }
  #inputBox {
    display: inline-block;
  }
  #probSize {
    width: 150px;
  }
  .sortButton {
    width: 120px;
    margin-right: 15px;
  }
  &lt;/style&gt;
  &lt;script&gt;
  function hexFromRGB(r, g, b) {
    var hex = [
      r.toString( 16 ),
      g.toString( 16 ),
      b.toString( 16 )
    ];
    $.each( hex, function( nr, val ) {
      if ( val.length === 1 ) {
        hex[ nr ] = "0" + val;
      }
    });
    return hex.join( "" ).toUpperCase();
  }

  function getBaseLog(x,y) {
        return Math.log(x) / Math.log(y);
  }

  function simulateNSqWork(n) {
    var total = 0;
    n *= n;
    n /= 51324;     //misc tuning constant
    n *= (1.05 - Math.random() / 10); //+- 5% variability
    var places = 5 - Math.floor(getBaseLog(n,10));
    if(places &lt; 0) places = 0;
    setTimeout(function() {
        $("#insertSorting").text( (n / 1000.0).toFixed(places) + " seconds");
        $( "#goNSqButton" ).removeAttr('disabled');
    }, n);
  }

  function addCommas(nStr) {
     nStr += '';
     x = nStr.split('.');
     x1 = x[0];
     x2 = x.length &gt; 1 ? '.' + x[1] : '';
     var rgx = /(\d+)(\d{3})/;
     while (rgx.test(x1)) {
           x1 = x1.replace(rgx, '$1' + ',' + '$2');
     }
     return x1 + x2;
  }

  function simulateNLogNWork(n) {
    var total = 0;
    n *= Math.log(n);  //base e but adjust to 2 with tuning constant
    n /= 47303;     //misc tuning constant
    n += 0.00234;     //misc tuning constant - make merge sort come in slower on small list
    n *= (1.05 - Math.random() / 10); //+- 5% variability
    var places = 5 - Math.floor(getBaseLog(n,10));
    if(places &lt; 0) places = 0;
    setTimeout(function() {
        $("#mergeSorting").text( (n / 1000.0).toFixed(places) + " seconds");
        $( "#goNLogNButton" ).removeAttr('disabled');
    }, n);
  }

  function changeSize() {
    var n = $( "#probSize" ).slider( "value" );
    $("#probSizeText").val( addCommas(Math.pow(10,n)) );
  }

  document.addEventListener('DOMContentLoaded', (event) =&gt; {
    $( "#probSize" ).slider({
      orientation: "horizontal",
      min: 1,
      max: 7,
      value: 1,
      slide: changeSize,
      change: changeSize
    });
    changeSize();
    $( "#goNSqButton" ).click( function() {
        var temp = $("#probSizeText").val().split(",").join("");
        var n = parseInt(temp);
        $( "#insertSorting" ).html("Sorting... &lt;img src='../_images/working.gif'&gt;");
        $( "#goNSqButton" ).attr('disabled','disabled');
        simulateNSqWork(n);
    });
    $( "#goNLogNButton" ).click( function() {
        var temp = $("#probSizeText").val().split(",").join("");
        var n = parseInt(temp);
        $( "#mergeSorting" ).html("Sorting... &lt;img src='../_images/working.gif'&gt;");
        $( "#goNLogNButton" ).attr('disabled','disabled');
        simulateNLogNWork(n);
    });
  });
  &lt;/script&gt;

&lt;fieldset id="sorterBox"&gt;
    &lt;legend&gt;Sort Timer&lt;/legend&gt;
    &lt;div id="sizeBox"&gt;
        &lt;span id="probSizeEntry"&gt;&lt;strong&gt;List Length:&lt;/strong&gt;&lt;/span&gt;
        &lt;div id="inputBox"&gt;
            &lt;input type="text" class="work" id="probSizeText" readonly="true" /&gt;
            &lt;div type="text" id="probSize"&gt; &lt;/div&gt;
         &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class="sortRow"&gt;
        &lt;button id="goNSqButton" class="sortButton"&gt;Insertion Sort&lt;/button&gt;&lt;span id="insertSorting"&gt;&lt;/span&gt;
    &lt;/div&gt;
    &lt;div class="sortRow"&gt;
        &lt;button id="goNLogNButton" class="sortButton"&gt;Merge Sort&lt;/button&gt;&lt;span id="mergeSorting"&gt;&lt;/span&gt;
    &lt;/div&gt;
&lt;/fieldset&gt;
&lt;br/&gt;</raw>
    </section>

