<section xml:id="algorithms_merge-sort-efficiency">
        <title>Merge Sort Efficiency</title>
        <p>So how efficient is Merge Sort? Well, for starters, remember that merging <term>n</term> items takes <m>O(n)</m> work. In other words, merging 5 items takes ~5 units of work, merging 20 items, takes ~20 units of work, etc&#8230; Now let&#8217;s do a rough analysis of how long it takes to do a merge sort on a list of length 1024.</p>
        <p>All the hard work takes place as we merge the lists back together:</p>
        <p><ul>
            <li>
                <p>The first merge for a list of 1024 things would be to merge 1024 single items into 512 lists of length two. Each merge would take ~2 units of work since there are two items in the new lists. 512 lists times 2 units of work = ~1024 units of work.</p>
            </li>
            <li>
                <p>The next level would be to merge those 512 lists of size 2 into 256 lists of size 4. Each merge in that level would take ~4 units of work. 256 lists times 4 units of work = 1024 units of work again.</p>
            </li>
        </ul></p>
        <p>The table below shows this and the pattern for the rest of the level:</p>
        <raw format="html" xml:space="preserve">&lt;table class="table" border="0"&gt;
    &lt;colgroup&gt;
        &lt;col width="5%"&gt;
        &lt;col width="35%"&gt;
        &lt;col width="15%"&gt;
        &lt;col width="15%"&gt;
        &lt;col width="30%"&gt;
    &lt;/colgroup&gt;
    &lt;thead valign="bottom" style="text-align: center;"&gt;
        &lt;tr class="row-odd"&gt;
            &lt;th class="head"&gt;Level&lt;/th&gt;
            &lt;th class="head"&gt;Description&lt;/th&gt;
            &lt;th class="head"&gt;Number of Lists&lt;/th&gt;
            &lt;th class="head"&gt;Size of Each List&lt;/th&gt;
            &lt;th class="head"&gt;Amount of Work&lt;/th&gt;
        &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody valign="top"&gt;
        &lt;tr class="row-even"&gt;
            &lt;td&gt;1&lt;/td&gt;
            &lt;td&gt;1024 lists of size 1 &lt;br&gt;
            into 512 lists of size 2&lt;/td&gt;
            &lt;td&gt;512&lt;/td&gt;
            &lt;td&gt;2&lt;/td&gt;
            &lt;td&gt;512 &#183; 2 = &lt;strong&gt;1024&lt;/strong&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr class="row-odd"&gt;
            &lt;td&gt;2&lt;/td&gt;
            &lt;td&gt;512 lists of size 2 &lt;br&gt;
            into 256 lists of size 4&lt;/td&gt;
            &lt;td&gt;256&lt;/td&gt;
            &lt;td&gt;4&lt;/td&gt;
            &lt;td&gt;256 &#183; 4 = &lt;strong&gt;1024&lt;/strong&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr class="row-even"&gt;
            &lt;td&gt;3&lt;/td&gt;
            &lt;td&gt;256 lists of size 4 &lt;br&gt;
            into 128 lists of size 8&lt;/td&gt;
            &lt;td&gt;128&lt;/td&gt;
            &lt;td&gt;8&lt;/td&gt;
            &lt;td&gt;128 &#183; 8 = &lt;strong&gt;1024&lt;/strong&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr class="row-odd"&gt;
            &lt;td&gt;...&lt;/td&gt;
            &lt;td&gt;...&lt;/td&gt;
            &lt;td&gt;...&lt;/td&gt;
            &lt;td&gt;...&lt;/td&gt;
            &lt;td&gt;...&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr class="row-even"&gt;
            &lt;td&gt;???&lt;/td&gt;
            &lt;td&gt;2 lists of size 512&lt;br&gt;
            into 1 list of size 1024&lt;/td&gt;
            &lt;td&gt;1&lt;/td&gt;
            &lt;td&gt;1024&lt;/td&gt;
            &lt;td&gt;1 &#183; 1024 = &lt;strong&gt;1024&lt;/strong&gt;&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;</raw>
        <p>Note that at each level the work is ~1024 units of time - exactly the number of items in the full list. Thus we can say each level takes <m>O(n)</m> work.</p>
        <p>The only other thing we need to figure out is &#8220;how many levels are required?&#8221; The table above skips a few steps in the middle. We could go back and add them in - starting with 1024 items the levels would look like:</p>
        <program language="none"><input>
1024 &#8594; 512 &#8594; 256 &#8594; 128 &#8594; 64 &#8594; 32 &#8594; 16 &#8594; 8 &#8594; 4 &#8594; 2 &#8594; 1
</input></program>
        <p>That is 10 levels of merging to group 1024 single items into one list of 1024.</p>
        <sidebar>
            <title>Wolfram Alpha</title>
            <p>You can use <url href="http://www.wolframalpha.com/" visual="http://www.wolframalpha.com/">Wolfram Alpha website</url> to calculate log base 2 by typing something like &#8220;log2(1024)&#8221;. Try it below.</p>
            <raw format="html" xml:space="preserve">&lt;div style="text-align: center;"&gt;&lt;form action="https://www.wolframalpha.com/input/"&gt;&lt;input type="text" id="input" style="width:100%" name="i"&gt;&lt;/input&gt;&lt;/form&gt;&lt;/div&gt;</raw>
        </sidebar>
        <p>As we saw with binary search, that progression - dividing by 2 repeatedly until we reach 1 - can also be determined by the mathematical function <m>log_2(n)</m>. <m>log_2(1024) = 10</m>. Using that, we could calculate the number of levels of merges required to do a Merge Sort on a list of 100,000 items: <m>log_2(100,000) &#8776; 16.61</m>. (Since we can&#8217;t do 16.61 merges levels, we would call that 17.)</p>
        <p>The formula also allows us to write a general formula for the overall work required for a Merge Sort. Starting with:</p>
        <p><m>\textrm{total work} = \textrm{work per level} &#183; \textrm{number of levels}</m></p>
        <p>We know that sorting <term>n</term> items will require <m>log_2(n)</m> levels and each level will take <term>n</term> work:</p>
        <p><m>\textrm{total work} = \textrm{n work} &#183; log_2(n) \textrm{ levels}</m></p>
        <p>Or:</p>
        <p><m>\textrm{total work} = n&#183;log_2(n)</m></p>
        <p>Merge Sort requires <m>O(n&#183;log_2(n))</m> work to sort a list of size <term>n</term>.</p>
    </section>

